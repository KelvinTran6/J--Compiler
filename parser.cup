/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!


   Node n;
  public parser(scanner s, ComplexSymbolFactory sf, Node n) {
    super(s,sf);
    this.n = n;
  }
:}

/* define how to connect to the scanner! */



/* Terminals (tokens returned by the scanner). */
terminal            IF, WHILE, BOOLEAN, ELSE, BREAK, RETURN, INT, TRUE, FALSE, VOID;
terminal            GT, GE, LT, LE, EQQ, DOT, ORB, CRB, OCB, CCB, OSB, CSB;
terminal            AND, OR, SEMI_COLON, COMMA, NE, EX, PLUS, MINUS, EQ;
terminal            DIVIDE, STAR, MOD, STRING, OPEN_STRING, INVALID_ESCAPE_CHARACTER, ID;
terminal Integer    NUMBER;
terminal            SEMI, TIMES;
terminal            UMINUS, LPAREN, RPAREN;


/* Non terminals */
non terminal            start_;
nonterminal             globaldeclarations, globaldeclaration, literal, type, variabledeclaration, identifier, functiondeclaration, functionheader;
nonterminal             functiondeclarator, formalparameterlist, formalparameter, mainfunctiondeclaration, mainfunctiondeclarator, block, blockstatements, blockstatement, statement, statementexpression, primary;
nonterminal             argumentlist, functioninvocation, postfixexpression, unaryexpression, multiplicativeexpression, additiveexpression, relationalexpression, equalityexpression, conditionalandexpression, conditionalorexpression;
nonterminal             assignmentexpression, assignment, expression, elsestatement;
    // used to store evaluated subexpressions

/* Precedences */
precedence left PLUS, MINUS;
precedence left STAR, MOD;
precedence left UMINUS;

/* The grammar rules */
start_           ::= globaldeclarations : v {:n.addNode(v);:}
                ;

literal         ::= NUMBER
                | STRING
                | TRUE
                | FALSE
                ;

type            ::= BOOLEAN
                | INT:e {:Node n = (Node)((Node)e).clone(); RESULT = n;:}
                ;

globaldeclarations      ::= globaldeclaration: g {:Node n = new Node("globaldeclarations"); n.addNode(g); RESULT = n;:}
                        | globaldeclarations globaldeclaration
                        ;

globaldeclaration       ::= variabledeclaration: v {:Node n = new Node("globaldeclaration"); n.addNode(v); RESULT = n;:}
                        | functiondeclaration
                        | mainfunctiondeclaration
                        ;

variabledeclaration     ::= type:t identifier:i SEMI_COLON {:RESULT = n; Node n = new Node("variabledeclaration"); n.addNode(t); n.addNode(i);RESULT = n;:}
                        ;

identifier              ::= ID:e {:Node n = (Node)((Node)e).clone(); RESULT = n;:}
                        ;

functiondeclaration     ::= functionheader block
                        ;

functionheader          ::= type functiondeclarator
                        | VOID functiondeclarator
                        ;

functiondeclarator      ::= identifier ORB formalparameterlist CRB
                        | identifier ORB CRB
                        ;

formalparameterlist     ::= formalparameter
                        | formalparameterlist COMMA formalparameter
                        ;

formalparameter         ::= type identifier
                        ;

mainfunctiondeclaration ::= mainfunctiondeclarator block
                        ;

mainfunctiondeclarator  ::= identifier ORB CRB
                        ;

block                   ::= OCB blockstatements CCB
                        | OCB CCB
                        ;

blockstatements         ::= blockstatement
                        | blockstatements blockstatement
                        ;

blockstatement          ::= variabledeclaration
                        | statement
                        ;

statement               ::= block
                        | SEMI_COLON
                        | statementexpression SEMI_COLON
                        | BREAK SEMI_COLON
                        | RETURN expression SEMI_COLON
                        | RETURN SEMI_COLON
                        | IF ORB expression CRB statement
                        | IF ORB expression CRB statement ELSE statement
                        | WHILE ORB expression CRB statement
                        ;


statementexpression     ::= assignment
                        | functioninvocation
                        ;

primary                 ::= literal
                        | ORB expression CRB
                        | functioninvocation
                        ;

argumentlist            ::= expression
                        | argumentlist COMMA expression
                        ;

functioninvocation      ::= identifier ORB argumentlist CRB
                        | identifier ORB CRB
                        ;

postfixexpression       ::= primary
                        | identifier
                        ;

assignment              ::= identifier EQ assignmentexpression
                        ;

unaryexpression         ::= MINUS unaryexpression
                        | EX unaryexpression
                        | postfixexpression
                        ;

multiplicativeexpression::= unaryexpression
                        | multiplicativeexpression STAR unaryexpression
                        | multiplicativeexpression DIVIDE unaryexpression
                        | multiplicativeexpression MOD unaryexpression
                        ;

additiveexpression      ::= multiplicativeexpression
                        | additiveexpression PLUS multiplicativeexpression
                        | additiveexpression MINUS multiplicativeexpression
                        ;

relationalexpression    ::= additiveexpression
                        | relationalexpression LE additiveexpression
                        | relationalexpression GE additiveexpression
                        | relationalexpression GT additiveexpression
                        | relationalexpression LT additiveexpression

                        ;

equalityexpression      ::= relationalexpression
                        | equalityexpression EQQ relationalexpression
                        | equalityexpression NE relationalexpression
                        ;

conditionalandexpression::= equalityexpression
                        | conditionalandexpression AND equalityexpression
                        ;

conditionalorexpression ::= conditionalandexpression
                        | conditionalorexpression OR conditionalandexpression
                        ;

assignmentexpression    ::= conditionalorexpression
                        | assignment
                        ;

expression              ::= assignmentexpression
                        ;

